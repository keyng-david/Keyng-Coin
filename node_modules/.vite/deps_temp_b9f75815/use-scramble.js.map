{
  "version": 3,
  "sources": ["../../use-scramble/src/index.ts"],
  "sourcesContent": ["import { useEffect, useRef } from 'react';\n\nfunction getRandomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction getRandomChar(range: RangeOrCharCodes) {\n  let rand = 0;\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1]);\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)];\n  }\n\n  return String.fromCharCode(rand);\n}\n\ntype RangeOrCharCodes = {\n  0: number;\n  1: number;\n} & Array<number>;\n\nexport type UseScrambleProps = {\n  /**\n   * When playOnMount is true, the animation will not play the first time a text input is provided.\n   */\n  playOnMount?: boolean;\n  /**\n   * Optional text input\n   */\n  text?: string;\n  /**\n   * 0-1 range that determines the scramble speed. A speed of 1 will redraw 60 times a second. A speed of 0 will pause the animation\n   *\n   * @default 1\n   */\n  speed?: number;\n  /**\n   * The controller will move forward along the text input and scramble more characters, at a pace of `tick` frames. Combined with the `speed` prop, you can control the animation rate\n   *\n   * @default 1\n   */\n  tick?: number;\n  /**\n   * Step forward on every tick\n   *\n   * @default 1\n   */\n  step?: number;\n\n  /**\n   * Chance of scrambling a character, range from 0 to 1, 0 being no chance, and 1 being 100% chance\n   */\n  chance?: number;\n  /**\n   * Randomize `seed` characters at random text positions\n   *\n   * @default 1\n   */\n  seed?: number;\n  /**\n   * How many times to scramble each character?\n   *\n   * @default 1\n   */\n  scramble?: number;\n  /**\n   * Characters to avoid scrambling\n   */\n  ignore?: string[];\n\n  /**\n   * Unicode character range for scrambler.\n   *\n   * If a tupple is provided [60,125], it will randomly choose a unicode character code within that range.\n   *\n   * If the array contains more than two unicode values, it will choose randomly from the array values only.\n   *\n   * To randomize with only two values, you can repeat them in the array [91,93,91,93]\n   *\n   * @default [65,125]\n   */\n  range?: RangeOrCharCodes;\n  /**\n   * Set the animation to overdrive mode, and set the unicode character code to use in the animation\n   */\n  overdrive?: boolean | number;\n  /**\n   * Always start text animation from an empty string\n   *\n   * @default false\n   */\n  overflow?: boolean;\n\n  /**\n   * Callback when animation starts drawing\n   */\n  onAnimationStart?: Function;\n\n  /**\n   * Callback for when the animation finished\n   */\n  onAnimationEnd?: Function;\n\n  /**\n   * onRedraw callback\n   */\n  onAnimationFrame?: (result: string) => void;\n};\n\nexport const useScramble = (props: UseScrambleProps) => {\n  let {\n    playOnMount = true,\n    text = '',\n    speed = 1,\n    seed = 1,\n    step = 1,\n    tick = 1,\n    scramble = 1,\n    chance = 1,\n    overflow = true,\n    range = [65, 125],\n    overdrive = true,\n    onAnimationStart,\n    onAnimationFrame,\n    onAnimationEnd,\n    ignore = [' '],\n  } = props;\n\n  const prefersReducedMotion =\n    typeof window !== \"undefined\"\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      : false;\n\n  if (prefersReducedMotion) {\n    step = text.length;\n    chance = 0;\n    overdrive = false;\n  }\n\n  // text node ref\n  const nodeRef = useRef<any>(null);\n\n  // animation frame request\n  const rafRef = useRef<number>(0);\n\n  // compute\n  const elapsedRef = useRef(0);\n  const fpsInterval = 1000 / (60 * speed);\n\n  // scramble step\n  const stepRef = useRef<number>(0);\n\n  // current character index ref\n  const scrambleIndexRef = useRef<number>(0);\n\n  // scramble controller\n  const controlRef = useRef<Array<string | number | null>>([]);\n\n  // overdrive control index\n  const overdriveRef = useRef<number>(0);\n\n  const setIfNotIgnored = (\n    value: string | number | null | number,\n    replace: string | number | null\n  ) => (ignore.includes(`${value}`) ? value : replace);\n\n  // pick random character ahead in the string, and add them to the randomizer\n  const seedForward = () => {\n    if (scrambleIndexRef.current === text.length) return;\n\n    for (var i = 0; i < seed; i++) {\n      const index = getRandomInt(\n        scrambleIndexRef.current,\n        controlRef.current.length\n      );\n      if (\n        typeof controlRef.current[index] !== 'number' &&\n        typeof controlRef.current[index] !== 'undefined'\n      ) {\n        controlRef.current[index] = setIfNotIgnored(\n          controlRef.current[index],\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\n        );\n      }\n    }\n  };\n\n  // add `step` characters to the randomizer, and increase the scrambleIndexRef pointer\n  const stepForward = () => {\n    for (var i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        const currentIndex = scrambleIndexRef.current;\n\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10;\n\n        controlRef.current[currentIndex] = setIfNotIgnored(\n          text[scrambleIndexRef.current],\n          shouldScramble\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\n            : 0\n        );\n        scrambleIndexRef.current++;\n      }\n    }\n  };\n\n  const resizeControl = () => {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop();\n      controlRef.current.splice(text.length, step);\n    }\n    for (var i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\n        );\n      }\n    }\n  };\n\n  const onOverdrive = () => {\n    if (!overdrive) return;\n\n    for (var i = 0; i < step; i++) {\n      const max = Math.max(controlRef.current.length, text.length);\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\n          text[overdriveRef.current],\n          String.fromCharCode(typeof overdrive === 'boolean' ? 95 : overdrive)\n        );\n        overdriveRef.current++;\n      }\n    }\n  };\n\n  const onTick = () => {\n    stepForward();\n    resizeControl();\n    seedForward();\n  };\n\n  /**\n   * Control the animation framerate, from the speed prop\n   *\n   * if speed is 0, stop the animation\n   */\n  const animate = (time: number) => {\n    if (!speed) return;\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    onOverdrive();\n\n    const timeElapsed = time - elapsedRef.current;\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time;\n\n      if (stepRef.current % tick === 0) {\n        onTick();\n      }\n\n      draw();\n    }\n  };\n\n  /**\n   * Redraw text on every animation frame\n   */\n  const draw = () => {\n    if (!nodeRef.current) return;\n\n    let result = '';\n\n    for (var i = 0; i < controlRef.current.length; i++) {\n      const controlValue = controlRef.current[i];\n\n      switch (true) {\n        /**\n         * a positive integer value, get a random character\n         */\n        case typeof controlValue === 'number' && controlValue > 0:\n          result += getRandomChar(range);\n\n          if (i <= scrambleIndexRef.current) {\n            // reduce scramble index only if it's past the scrambleIndexRef\n            controlRef.current[i] = (controlRef.current[i] as number) - 1;\n          }\n          break;\n\n        /**\n         * a string from the previous text\n         */\n        case typeof controlValue === 'string' &&\n          (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue;\n          break;\n\n        /**\n         * before scramble index, and equal to the string\n         */\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i];\n          break;\n\n        /**\n         * scramble has finished\n         */\n        case controlValue === 0 && i < text.length:\n          result += text[i];\n          controlRef.current[i] = text[i];\n          break;\n\n        default:\n          result += '';\n      }\n    }\n\n    // set text\n    nodeRef.current.innerHTML = result;\n\n    onAnimationFrame && onAnimationFrame(result);\n\n    /**\n     * Exit if the result is equal to the input\n     *\n     * - Trim control to text length\n     * - fire onAnimationEnd\n     */\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length);\n      onAnimationEnd && onAnimationEnd();\n\n      cancelAnimationFrame(rafRef.current);\n    }\n\n    stepRef.current++;\n  };\n\n  /**\n   * Reset scramble controls\n   *\n   * if overflow is true, overflow the control to the an empty array, the size of the text input. This will cause the animation to play from an empty string\n   */\n  const reset = () => {\n    stepRef.current = 0;\n    scrambleIndexRef.current = 0;\n    overdriveRef.current = 0;\n    if (!overflow) {\n      controlRef.current = new Array(text?.length);\n    }\n  };\n\n  /**\n   * Restarts the animation\n   *\n   * Cancels the current animation frame, resets the scramble index and other controls, and requests a new animation\n   */\n  const play = () => {\n    cancelAnimationFrame(rafRef.current);\n    reset();\n    onAnimationStart && onAnimationStart();\n    rafRef.current = requestAnimationFrame(animate);\n  };\n\n  /**\n   * reset scramble when text input is changed\n   */\n  useEffect(() => {\n    reset();\n  }, [text]);\n\n  /**\n   * start or stop animation when text and speed change\n   */\n  useEffect(() => {\n    cancelAnimationFrame(rafRef.current);\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    // cancel raf on unmount\n    return () => {\n      cancelAnimationFrame(rafRef.current);\n    };\n  }, [animate]);\n\n  useEffect(() => {\n    if (!playOnMount) {\n      controlRef.current = text.split('');\n      stepRef.current = text.length;\n      scrambleIndexRef.current = text.length;\n      overdriveRef.current = text.length;\n      draw();\n      cancelAnimationFrame(rafRef.current);\n    }\n  }, []);\n\n  return { ref: nodeRef, replay: play };\n};\n"],
  "mappings": ";;;;;;;;;AAEA,SAASA,aAAaC,KAAaC,KAAW;AAC5C,SAAOC,KAAKC,MAAMD,KAAKE,OAAM,KAAMH,MAAMD,MAAM,EAAE,IAAIA;AACvD;AAEA,SAASK,cAAcC,OAAuB;AAC5C,MAAIC,OAAO;AACX,MAAID,MAAME,WAAW,GAAG;AACtBD,WAAOR,aAAaO,MAAM,CAAC,GAAGA,MAAM,CAAC,CAAC;SACjC;AACLC,WAAOD,MAAMP,aAAa,GAAGO,MAAME,SAAS,CAAC,CAAC;;AAGhD,SAAOC,OAAOC,aAAaH,IAAI;AACjC;IA+FaI,cAAc,SAAdA,aAAeC,OAAuB;AACjD,MAAA,qBAgBIA,MAfFC,aAAAA,cAAW,uBAAA,SAAG,OAAI,oBAAA,cAehBD,MAdFE,MAAAA,OAAI,gBAAA,SAAG,KAAE,aAAA,eAcPF,MAbFG,OAAAA,QAAK,iBAAA,SAAG,IAAC,cAAA,cAaPH,MAZFI,MAAAA,OAAI,gBAAA,SAAG,IAAC,aAAA,cAYNJ,MAXFK,MAAAA,OAAI,gBAAA,SAAG,IAAC,aAAA,cAWNL,MAVFM,MAAAA,OAAI,gBAAA,SAAG,IAAC,aAAA,kBAUNN,MATFO,UAAAA,WAAQ,oBAAA,SAAG,IAAC,iBAAA,gBASVP,MARFQ,QAAAA,SAAM,kBAAA,SAAG,IAAC,eAAA,kBAQRR,MAPFS,UAAAA,WAAQ,oBAAA,SAAG,OAAI,iBAAA,eAObT,MANFN,OAAAA,QAAK,iBAAA,SAAG,CAAC,IAAI,GAAG,IAAC,cAAA,mBAMfM,MALFU,WAAAA,YAAS,qBAAA,SAAG,OAAI,kBAChBC,mBAIEX,MAJFW,kBACAC,mBAGEZ,MAHFY,kBACAC,iBAEEb,MAFFa,gBAAc,gBAEZb,MADFc,QAAAA,SAAM,kBAAA,SAAG,CAAC,GAAG,IAAC;AAGhB,MAAMC,uBACJ,OAAOC,WAAW,cACdA,OAAOC,WAAW,kCAAkC,EAAEC,UACtD;AAEN,MAAIH,sBAAsB;AACxBV,WAAOH,KAAKN;AACZY,aAAS;AACTE,gBAAY;;AAId,MAAMS,cAAUC,qBAAY,IAAI;AAGhC,MAAMC,aAASD,qBAAe,CAAC;AAG/B,MAAME,iBAAaF,qBAAO,CAAC;AAC3B,MAAMG,cAAc,OAAQ,KAAKpB;AAGjC,MAAMqB,cAAUJ,qBAAe,CAAC;AAGhC,MAAMK,uBAAmBL,qBAAe,CAAC;AAGzC,MAAMM,iBAAaN,qBAAsC,CAAA,CAAE;AAG3D,MAAMO,mBAAeP,qBAAe,CAAC;AAErC,MAAMQ,kBAAkB,SAAlBA,iBACJC,OACAC,SAA+B;AAAA,WAC3BhB,OAAOiB,SAAQ,KAAIF,KAAK,IAAMA,QAAQC;;AAG5C,MAAME,cAAc,SAAdA,eAAW;AACf,QAAIP,iBAAiBQ,YAAY/B,KAAKN,OAAQ;AAE9C,aAASsC,IAAI,GAAGA,IAAI9B,MAAM8B,KAAK;AAC7B,UAAMC,QAAQhD,aACZsC,iBAAiBQ,SACjBP,WAAWO,QAAQrC,MAAM;AAE3B,UACE,OAAO8B,WAAWO,QAAQE,KAAK,MAAM,YACrC,OAAOT,WAAWO,QAAQE,KAAK,MAAM,aACrC;AACAT,mBAAWO,QAAQE,KAAK,IAAIP,gBAC1BF,WAAWO,QAAQE,KAAK,GACxBhD,aAAa,GAAG,EAAE,MAAM,IAAIqB,UAAU,KAAKD,YAAYH,OAAO,CAAC;;;;AAOvE,MAAMgC,cAAc,SAAdA,eAAW;AACf,aAASF,IAAI,GAAGA,IAAI7B,MAAM6B,KAAK;AAC7B,UAAIT,iBAAiBQ,UAAU/B,KAAKN,QAAQ;AAC1C,YAAMyC,eAAeZ,iBAAiBQ;AAEtC,YAAMK,iBAAiBnD,aAAa,GAAG,EAAE,MAAM,IAAIqB,UAAU;AAE7DkB,mBAAWO,QAAQI,YAAY,IAAIT,gBACjC1B,KAAKuB,iBAAiBQ,OAAO,GAC7BK,iBACI/B,WAAWpB,aAAa,GAAGG,KAAKiD,KAAKhC,WAAW,CAAC,CAAC,IAClD,CAAC;AAEPkB,yBAAiBQ;;;;AAKvB,MAAMO,gBAAgB,SAAhBA,iBAAa;AACjB,QAAItC,KAAKN,SAAS8B,WAAWO,QAAQrC,QAAQ;AAC3C8B,iBAAWO,QAAQQ,IAAG;AACtBf,iBAAWO,QAAQS,OAAOxC,KAAKN,QAAQS,IAAI;;AAE7C,aAAS6B,IAAI,GAAGA,IAAI7B,MAAM6B,KAAK;AAC7B,UAAIR,WAAWO,QAAQrC,SAASM,KAAKN,QAAQ;AAC3C8B,mBAAWO,QAAQU,KACjBf,gBAAgB1B,KAAKwB,WAAWO,QAAQrC,SAAS,CAAC,GAAG,IAAI,CAAC;;;;AAMlE,MAAMgD,cAAc,SAAdA,eAAW;AACf,QAAI,CAAClC,UAAW;AAEhB,aAASwB,IAAI,GAAGA,IAAI7B,MAAM6B,KAAK;AAC7B,UAAM7C,MAAMC,KAAKD,IAAIqC,WAAWO,QAAQrC,QAAQM,KAAKN,MAAM;AAC3D,UAAI+B,aAAaM,UAAU5C,KAAK;AAC9BqC,mBAAWO,QAAQN,aAAaM,OAAO,IAAIL,gBACzC1B,KAAKyB,aAAaM,OAAO,GACzBpC,OAAOC,aAAa,OAAOY,cAAc,YAAY,KAAKA,SAAS,CAAC;AAEtEiB,qBAAaM;;;;AAKnB,MAAMY,SAAS,SAATA,UAAM;AACVT,gBAAW;AACXI,kBAAa;AACbR,gBAAW;;AAQb,MAAMc,UAAU,SAAVA,SAAWC,MAAY;AAC3B,QAAI,CAAC5C,MAAO;AAEZkB,WAAOY,UAAUe,sBAAsBF,QAAO;AAE9CF,gBAAW;AAEX,QAAMK,cAAcF,OAAOzB,WAAWW;AACtC,QAAIgB,cAAc1B,aAAa;AAC7BD,iBAAWW,UAAUc;AAErB,UAAIvB,QAAQS,UAAU3B,SAAS,GAAG;AAChCuC,eAAM;;AAGRK,WAAI;;;AAOR,MAAMA,OAAO,SAAPA,QAAI;AACR,QAAI,CAAC/B,QAAQc,QAAS;AAEtB,QAAIkB,SAAS;AAEb,aAASjB,IAAI,GAAGA,IAAIR,WAAWO,QAAQrC,QAAQsC,KAAK;AAClD,UAAMkB,eAAe1B,WAAWO,QAAQC,CAAC;AAEzC,cAAQ,MAAI;QAIV,MAAK,OAAOkB,iBAAiB,YAAYA,eAAe;AACtDD,oBAAU1D,cAAcC,KAAK;AAE7B,cAAIwC,KAAKT,iBAAiBQ,SAAS;AAEjCP,uBAAWO,QAAQC,CAAC,IAAKR,WAAWO,QAAQC,CAAC,IAAe;;AAE9D;QAKF,MAAK,OAAOkB,iBAAiB,aAC1BlB,KAAKhC,KAAKN,UAAUsC,KAAKT,iBAAiBQ;AAC3CkB,oBAAUC;AACV;QAKF,MAAKA,iBAAiBlD,KAAKgC,CAAC,KAAKA,IAAIT,iBAAiBQ;AACpDkB,oBAAUjD,KAAKgC,CAAC;AAChB;QAKF,MAAKkB,iBAAiB,KAAKlB,IAAIhC,KAAKN;AAClCuD,oBAAUjD,KAAKgC,CAAC;AAChBR,qBAAWO,QAAQC,CAAC,IAAIhC,KAAKgC,CAAC;AAC9B;QAEF;AACEiB,oBAAU;;;AAKhBhC,YAAQc,QAAQoB,YAAYF;AAE5BvC,wBAAoBA,iBAAiBuC,MAAM;AAQ3C,QAAIA,WAAWjD,MAAM;AACnBwB,iBAAWO,QAAQS,OAAOxC,KAAKN,QAAQ8B,WAAWO,QAAQrC,MAAM;AAChEiB,wBAAkBA,eAAc;AAEhCyC,2BAAqBjC,OAAOY,OAAO;;AAGrCT,YAAQS;;AAQV,MAAMsB,QAAQ,SAARA,SAAK;AACT/B,YAAQS,UAAU;AAClBR,qBAAiBQ,UAAU;AAC3BN,iBAAaM,UAAU;AACvB,QAAI,CAACxB,UAAU;AACbiB,iBAAWO,UAAU,IAAIuB,MAAMtD,QAAI,OAAA,SAAJA,KAAMN,MAAM;;;AAS/C,MAAM6D,OAAO,SAAPA,QAAI;AACRH,yBAAqBjC,OAAOY,OAAO;AACnCsB,UAAK;AACL5C,wBAAoBA,iBAAgB;AACpCU,WAAOY,UAAUe,sBAAsBF,OAAO;;AAMhDY,8BAAU,WAAA;AACRH,UAAK;KACJ,CAACrD,IAAI,CAAC;AAKTwD,8BAAU,WAAA;AACRJ,yBAAqBjC,OAAOY,OAAO;AAEnCZ,WAAOY,UAAUe,sBAAsBF,OAAO;AAG9C,WAAO,WAAA;AACLQ,2BAAqBjC,OAAOY,OAAO;;KAEpC,CAACa,OAAO,CAAC;AAEZY,8BAAU,WAAA;AACR,QAAI,CAACzD,aAAa;AAChByB,iBAAWO,UAAU/B,KAAKyD,MAAM,EAAE;AAClCnC,cAAQS,UAAU/B,KAAKN;AACvB6B,uBAAiBQ,UAAU/B,KAAKN;AAChC+B,mBAAaM,UAAU/B,KAAKN;AAC5BsD,WAAI;AACJI,2BAAqBjC,OAAOY,OAAO;;KAEpC,CAAA,CAAE;AAEL,SAAO;IAAE2B,KAAKzC;IAAS0C,QAAQJ;;AACjC;",
  "names": ["getRandomInt", "min", "max", "Math", "floor", "random", "getRandomChar", "range", "rand", "length", "String", "fromCharCode", "useScramble", "props", "playOnMount", "text", "speed", "seed", "step", "tick", "scramble", "chance", "overflow", "overdrive", "onAnimationStart", "onAnimationFrame", "onAnimationEnd", "ignore", "prefersReducedMotion", "window", "matchMedia", "matches", "nodeRef", "useRef", "rafRef", "elapsedRef", "fpsInterval", "stepRef", "scrambleIndexRef", "controlRef", "overdriveRef", "setIfNotIgnored", "value", "replace", "includes", "seedForward", "current", "i", "index", "stepForward", "currentIndex", "shouldScramble", "ceil", "resizeControl", "pop", "splice", "push", "onOverdrive", "onTick", "animate", "time", "requestAnimationFrame", "timeElapsed", "draw", "result", "controlValue", "innerHTML", "cancelAnimationFrame", "reset", "Array", "play", "useEffect", "split", "ref", "replay"]
}
