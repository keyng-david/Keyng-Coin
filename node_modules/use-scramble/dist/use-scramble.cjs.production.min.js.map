{"version":3,"file":"use-scramble.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\n\nfunction getRandomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction getRandomChar(range: RangeOrCharCodes) {\n  let rand = 0;\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1]);\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)];\n  }\n\n  return String.fromCharCode(rand);\n}\n\ntype RangeOrCharCodes = {\n  0: number;\n  1: number;\n} & Array<number>;\n\nexport type UseScrambleProps = {\n  /**\n   * When playOnMount is true, the animation will not play the first time a text input is provided.\n   */\n  playOnMount?: boolean;\n  /**\n   * Optional text input\n   */\n  text?: string;\n  /**\n   * 0-1 range that determines the scramble speed. A speed of 1 will redraw 60 times a second. A speed of 0 will pause the animation\n   *\n   * @default 1\n   */\n  speed?: number;\n  /**\n   * The controller will move forward along the text input and scramble more characters, at a pace of `tick` frames. Combined with the `speed` prop, you can control the animation rate\n   *\n   * @default 1\n   */\n  tick?: number;\n  /**\n   * Step forward on every tick\n   *\n   * @default 1\n   */\n  step?: number;\n\n  /**\n   * Chance of scrambling a character, range from 0 to 1, 0 being no chance, and 1 being 100% chance\n   */\n  chance?: number;\n  /**\n   * Randomize `seed` characters at random text positions\n   *\n   * @default 1\n   */\n  seed?: number;\n  /**\n   * How many times to scramble each character?\n   *\n   * @default 1\n   */\n  scramble?: number;\n  /**\n   * Characters to avoid scrambling\n   */\n  ignore?: string[];\n\n  /**\n   * Unicode character range for scrambler.\n   *\n   * If a tupple is provided [60,125], it will randomly choose a unicode character code within that range.\n   *\n   * If the array contains more than two unicode values, it will choose randomly from the array values only.\n   *\n   * To randomize with only two values, you can repeat them in the array [91,93,91,93]\n   *\n   * @default [65,125]\n   */\n  range?: RangeOrCharCodes;\n  /**\n   * Set the animation to overdrive mode, and set the unicode character code to use in the animation\n   */\n  overdrive?: boolean | number;\n  /**\n   * Always start text animation from an empty string\n   *\n   * @default false\n   */\n  overflow?: boolean;\n\n  /**\n   * Callback when animation starts drawing\n   */\n  onAnimationStart?: Function;\n\n  /**\n   * Callback for when the animation finished\n   */\n  onAnimationEnd?: Function;\n\n  /**\n   * onRedraw callback\n   */\n  onAnimationFrame?: (result: string) => void;\n};\n\nexport const useScramble = (props: UseScrambleProps) => {\n  let {\n    playOnMount = true,\n    text = '',\n    speed = 1,\n    seed = 1,\n    step = 1,\n    tick = 1,\n    scramble = 1,\n    chance = 1,\n    overflow = true,\n    range = [65, 125],\n    overdrive = true,\n    onAnimationStart,\n    onAnimationFrame,\n    onAnimationEnd,\n    ignore = [' '],\n  } = props;\n\n  const prefersReducedMotion =\n    typeof window !== \"undefined\"\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      : false;\n\n  if (prefersReducedMotion) {\n    step = text.length;\n    chance = 0;\n    overdrive = false;\n  }\n\n  // text node ref\n  const nodeRef = useRef<any>(null);\n\n  // animation frame request\n  const rafRef = useRef<number>(0);\n\n  // compute\n  const elapsedRef = useRef(0);\n  const fpsInterval = 1000 / (60 * speed);\n\n  // scramble step\n  const stepRef = useRef<number>(0);\n\n  // current character index ref\n  const scrambleIndexRef = useRef<number>(0);\n\n  // scramble controller\n  const controlRef = useRef<Array<string | number | null>>([]);\n\n  // overdrive control index\n  const overdriveRef = useRef<number>(0);\n\n  const setIfNotIgnored = (\n    value: string | number | null | number,\n    replace: string | number | null\n  ) => (ignore.includes(`${value}`) ? value : replace);\n\n  // pick random character ahead in the string, and add them to the randomizer\n  const seedForward = () => {\n    if (scrambleIndexRef.current === text.length) return;\n\n    for (var i = 0; i < seed; i++) {\n      const index = getRandomInt(\n        scrambleIndexRef.current,\n        controlRef.current.length\n      );\n      if (\n        typeof controlRef.current[index] !== 'number' &&\n        typeof controlRef.current[index] !== 'undefined'\n      ) {\n        controlRef.current[index] = setIfNotIgnored(\n          controlRef.current[index],\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\n        );\n      }\n    }\n  };\n\n  // add `step` characters to the randomizer, and increase the scrambleIndexRef pointer\n  const stepForward = () => {\n    for (var i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        const currentIndex = scrambleIndexRef.current;\n\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10;\n\n        controlRef.current[currentIndex] = setIfNotIgnored(\n          text[scrambleIndexRef.current],\n          shouldScramble\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\n            : 0\n        );\n        scrambleIndexRef.current++;\n      }\n    }\n  };\n\n  const resizeControl = () => {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop();\n      controlRef.current.splice(text.length, step);\n    }\n    for (var i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\n        );\n      }\n    }\n  };\n\n  const onOverdrive = () => {\n    if (!overdrive) return;\n\n    for (var i = 0; i < step; i++) {\n      const max = Math.max(controlRef.current.length, text.length);\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\n          text[overdriveRef.current],\n          String.fromCharCode(typeof overdrive === 'boolean' ? 95 : overdrive)\n        );\n        overdriveRef.current++;\n      }\n    }\n  };\n\n  const onTick = () => {\n    stepForward();\n    resizeControl();\n    seedForward();\n  };\n\n  /**\n   * Control the animation framerate, from the speed prop\n   *\n   * if speed is 0, stop the animation\n   */\n  const animate = (time: number) => {\n    if (!speed) return;\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    onOverdrive();\n\n    const timeElapsed = time - elapsedRef.current;\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time;\n\n      if (stepRef.current % tick === 0) {\n        onTick();\n      }\n\n      draw();\n    }\n  };\n\n  /**\n   * Redraw text on every animation frame\n   */\n  const draw = () => {\n    if (!nodeRef.current) return;\n\n    let result = '';\n\n    for (var i = 0; i < controlRef.current.length; i++) {\n      const controlValue = controlRef.current[i];\n\n      switch (true) {\n        /**\n         * a positive integer value, get a random character\n         */\n        case typeof controlValue === 'number' && controlValue > 0:\n          result += getRandomChar(range);\n\n          if (i <= scrambleIndexRef.current) {\n            // reduce scramble index only if it's past the scrambleIndexRef\n            controlRef.current[i] = (controlRef.current[i] as number) - 1;\n          }\n          break;\n\n        /**\n         * a string from the previous text\n         */\n        case typeof controlValue === 'string' &&\n          (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue;\n          break;\n\n        /**\n         * before scramble index, and equal to the string\n         */\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i];\n          break;\n\n        /**\n         * scramble has finished\n         */\n        case controlValue === 0 && i < text.length:\n          result += text[i];\n          controlRef.current[i] = text[i];\n          break;\n\n        default:\n          result += '';\n      }\n    }\n\n    // set text\n    nodeRef.current.innerHTML = result;\n\n    onAnimationFrame && onAnimationFrame(result);\n\n    /**\n     * Exit if the result is equal to the input\n     *\n     * - Trim control to text length\n     * - fire onAnimationEnd\n     */\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length);\n      onAnimationEnd && onAnimationEnd();\n\n      cancelAnimationFrame(rafRef.current);\n    }\n\n    stepRef.current++;\n  };\n\n  /**\n   * Reset scramble controls\n   *\n   * if overflow is true, overflow the control to the an empty array, the size of the text input. This will cause the animation to play from an empty string\n   */\n  const reset = () => {\n    stepRef.current = 0;\n    scrambleIndexRef.current = 0;\n    overdriveRef.current = 0;\n    if (!overflow) {\n      controlRef.current = new Array(text?.length);\n    }\n  };\n\n  /**\n   * Restarts the animation\n   *\n   * Cancels the current animation frame, resets the scramble index and other controls, and requests a new animation\n   */\n  const play = () => {\n    cancelAnimationFrame(rafRef.current);\n    reset();\n    onAnimationStart && onAnimationStart();\n    rafRef.current = requestAnimationFrame(animate);\n  };\n\n  /**\n   * reset scramble when text input is changed\n   */\n  useEffect(() => {\n    reset();\n  }, [text]);\n\n  /**\n   * start or stop animation when text and speed change\n   */\n  useEffect(() => {\n    cancelAnimationFrame(rafRef.current);\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    // cancel raf on unmount\n    return () => {\n      cancelAnimationFrame(rafRef.current);\n    };\n  }, [animate]);\n\n  useEffect(() => {\n    if (!playOnMount) {\n      controlRef.current = text.split('');\n      stepRef.current = text.length;\n      scrambleIndexRef.current = text.length;\n      overdriveRef.current = text.length;\n      draw();\n      cancelAnimationFrame(rafRef.current);\n    }\n  }, []);\n\n  return { ref: nodeRef, replay: play };\n};\n"],"names":["getRandomInt","min","max","Math","floor","random","getRandomChar","range","rand","length","String","fromCharCode","props","playOnMount","_props$text","text","_props$speed","speed","_props$seed","seed","_props$step","step","_props$tick","tick","_props$scramble","scramble","_props$chance","chance","_props$overflow","overflow","_props$range","_props$overdrive","overdrive","onAnimationStart","onAnimationFrame","onAnimationEnd","_props$ignore","ignore","window","matchMedia","matches","nodeRef","useRef","rafRef","elapsedRef","fpsInterval","stepRef","scrambleIndexRef","controlRef","overdriveRef","setIfNotIgnored","value","replace","includes","animate","time","current","requestAnimationFrame","i","onOverdrive","currentIndex","shouldScramble","ceil","stepForward","pop","splice","push","resizeControl","index","seedForward","draw","result","controlValue","innerHTML","cancelAnimationFrame","reset","Array","useEffect","split","ref","replay"],"mappings":"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"}