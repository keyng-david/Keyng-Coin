{
  "version": 3,
  "sources": ["../../../../src/cli/lib/components.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context, changeSpinner, logError } from \"../../bundler/context.js\";\nimport { configFromProjectConfig, readProjectConfig } from \"./config.js\";\nimport { finishPush, startPush, waitForSchema } from \"./deploy2.js\";\nimport { version } from \"../version.js\";\nimport { PushOptions } from \"./push.js\";\nimport { ensureHasConvexDependency, functionsDir } from \"./utils.js\";\nimport {\n  bundleDefinitions,\n  bundleImplementations,\n  componentGraph,\n} from \"./components/definition/bundle.js\";\nimport { isComponentDirectory } from \"./components/definition/directoryStructure.js\";\nimport {\n  doFinalComponentCodegen,\n  doInitialComponentCodegen,\n} from \"./codegen.js\";\nimport {\n  AppDefinitionConfig,\n  ComponentDefinitionConfig,\n} from \"./deployApi/definitionConfig.js\";\nimport { typeCheckFunctionsInMode } from \"./typecheck.js\";\nimport { withTmpDir } from \"../../bundler/fs.js\";\n\nexport async function runComponentsPush(ctx: Context, options: PushOptions) {\n  const { configPath, projectConfig } = await readProjectConfig(ctx);\n  const verbose = options.verbose || options.dryRun;\n  await ensureHasConvexDependency(ctx, \"push\");\n\n  if (!options.codegen) {\n    logError(ctx, \"disabling codegen not allowed\");\n    await ctx.crash(1, \"fatal\");\n  }\n  if (options.dryRun) {\n    logError(ctx, \"dryRun not allowed yet\");\n    await ctx.crash(1, \"fatal\");\n  }\n  if (options.debugBundlePath) {\n    logError(ctx, \"debugBundlePath not allowed yet\");\n    await ctx.crash(1, \"fatal\");\n  }\n  if (!options.enableComponents) {\n    logError(ctx, \"enableComponents must be true\");\n    await ctx.crash(1, \"fatal\");\n  }\n\n  const convexDir = functionsDir(configPath, projectConfig);\n\n  // '.' means use the process current working directory, it's the default behavior.\n  // Spelling it out here to be explicit for a future where this code can run\n  // from other directories.\n  // In esbuild the working directory is used to print error messages and resolving\n  // relatives paths passed to it. It generally doesn't matter for resolving imports,\n  // imports are resolved from the file where they are written.\n  const absWorkingDir = path.resolve(\".\");\n  const isComponent = isComponentDirectory(ctx, convexDir, true);\n  if (isComponent.kind === \"err\") {\n    logError(\n      ctx,\n      `Invalid component root directory (${isComponent.why}): ${convexDir}`,\n    );\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  const rootComponent = isComponent.component;\n\n  changeSpinner(ctx, \"Traversing component definitions...\");\n  // Create a list of relevant component directories. These are just for knowing\n  // while directories to bundle in bundleDefinitions and bundleImplementations.\n  // This produces a bundle in memory as a side effect but it's thrown away.\n  //\n  // This is the very first time we traverse the component graph.\n  // We're just traversing to discover\n  const { components, dependencyGraph } = await componentGraph(\n    ctx,\n    absWorkingDir,\n    rootComponent,\n    verbose,\n  );\n\n  changeSpinner(ctx, \"Generating server code...\");\n  await withTmpDir(async (tmpDir) => {\n    await doInitialComponentCodegen(ctx, tmpDir, rootComponent, options);\n    for (const directory of components.values()) {\n      await doInitialComponentCodegen(ctx, tmpDir, directory, options);\n    }\n  });\n\n  changeSpinner(ctx, \"Bundling component definitions...\");\n  // This bundles everything but the actual function definitions\n  const {\n    appDefinitionSpecWithoutImpls,\n    componentDefinitionSpecsWithoutImpls,\n  } = await bundleDefinitions(\n    ctx,\n    absWorkingDir,\n    dependencyGraph,\n    rootComponent,\n    // Note that this *includes* the root component.\n    [...components.values()],\n  );\n\n  const { config: localConfig } = await configFromProjectConfig(\n    ctx,\n    projectConfig,\n    configPath,\n    verbose,\n  );\n  changeSpinner(ctx, \"Bundling component schemas and implementations...\");\n  const { appImplementation, componentImplementations } =\n    await bundleImplementations(\n      ctx,\n      rootComponent,\n      [...components.values()],\n      verbose,\n    );\n\n  const appDefinition: AppDefinitionConfig = {\n    ...appDefinitionSpecWithoutImpls,\n    auth: localConfig.authConfig || null,\n    ...appImplementation,\n  };\n\n  const componentDefinitions: ComponentDefinitionConfig[] = [];\n  for (const componentDefinition of componentDefinitionSpecsWithoutImpls) {\n    const impl = componentImplementations.filter(\n      (impl) =>\n        // convert from ComponentPath\n        path.resolve(rootComponent.path, impl.definitionPath) ===\n        componentDefinition.definitionPath,\n    )[0];\n    if (!impl) {\n      console.log(\n        `missing! couldn't find ${componentDefinition.definitionPath} in ${componentImplementations.map((impl) => path.resolve(rootComponent.path, impl.definitionPath)).toString()}`,\n      );\n      return await ctx.crash(1, \"fatal\");\n    }\n    componentDefinitions.push({\n      ...componentDefinition,\n      ...impl,\n    });\n  }\n\n  // We're just using the version this CLI is running with for now.\n  // This could be different than the version of `convex` the app runs with\n  // if the CLI is installed globally.\n  const udfServerVersion = version;\n\n  const startPushResponse = await startPush(\n    ctx,\n    options.url,\n    {\n      adminKey: options.adminKey,\n      dryRun: false,\n      functions: projectConfig.functions,\n      udfServerVersion,\n      appDefinition,\n      componentDefinitions,\n      nodeDependencies: [],\n    },\n    verbose,\n  );\n\n  verbose && console.log(\"startPush:\", startPushResponse);\n\n  changeSpinner(ctx, \"Finalizing code generation...\");\n  await withTmpDir(async (tmpDir) => {\n    await doFinalComponentCodegen(\n      ctx,\n      tmpDir,\n      rootComponent,\n      rootComponent,\n      startPushResponse,\n    );\n    for (const directory of components.values()) {\n      await doFinalComponentCodegen(\n        ctx,\n        tmpDir,\n        rootComponent,\n        directory,\n        startPushResponse,\n      );\n    }\n  });\n\n  changeSpinner(ctx, \"Running TypeScript...\");\n  await typeCheckFunctionsInMode(ctx, options.typecheck, rootComponent.path);\n  for (const directory of components.values()) {\n    await typeCheckFunctionsInMode(ctx, options.typecheck, directory.path);\n  }\n\n  changeSpinner(ctx, \"Waiting for schema...\");\n  await waitForSchema(ctx, options.adminKey, options.url, startPushResponse);\n\n  const finishPushResponse = await finishPush(\n    ctx,\n    options.adminKey,\n    options.url,\n    startPushResponse,\n  );\n  verbose && console.log(\"finishPush:\", finishPushResponse);\n}\n"],
  "mappings": "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",
  "names": ["impl"]
}
