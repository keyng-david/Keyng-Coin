import { useCallback as b, useState as O, useMemo as R, useEffect as U } from "react";
class y extends Error {
  constructor(e, r, n) {
    super(r, { cause: n }), this.type = e, Object.setPrototypeOf(this, y.prototype);
  }
}
function _(t, e, r) {
  return new y(t, e, r);
}
const x = "ERR_UNEXPECTED_TYPE", $ = "ERR_PARSE";
function h() {
  return _(x, "Value has unexpected type");
}
class E {
  constructor(e, r, n) {
    this.parser = e, this.isOptional = r, this.type = n;
  }
  /**
   * Attempts to parse passed value
   * @param value - value to parse.
   * @throws {SDKError} ERR_PARSE
   * @see ERR_PARSE
   */
  parse(e) {
    if (!(this.isOptional && e === void 0))
      try {
        return this.parser(e);
      } catch (r) {
        throw _(
          $,
          `Unable to parse value${this.type ? ` as ${this.type}` : ""}`,
          r
        );
      }
  }
  optional() {
    return this.isOptional = !0, this;
  }
}
function f(t, e) {
  return () => new E(t, !1, e);
}
const c = f((t) => {
  if (typeof t == "boolean")
    return t;
  const e = String(t);
  if (e === "1" || e === "true")
    return !0;
  if (e === "0" || e === "false")
    return !1;
  throw h();
}, "boolean");
function S(t, e) {
  const r = {};
  for (const n in t) {
    const o = t[n];
    if (!o)
      continue;
    let u, i;
    if (typeof o == "function" || "parse" in o)
      u = n, i = typeof o == "function" ? o : o.parse.bind(o);
    else {
      const { type: a } = o;
      u = o.from || n, i = typeof a == "function" ? a : a.parse.bind(a);
    }
    try {
      const a = i(e(u));
      a !== void 0 && (r[n] = a);
    } catch (a) {
      throw _($, `Unable to parse field "${n}"`, a);
    }
  }
  return r;
}
function N(t) {
  let e = t;
  if (typeof e == "string" && (e = JSON.parse(e)), typeof e != "object" || e === null || Array.isArray(e))
    throw h();
  return e;
}
function p(t, e) {
  return new E((r) => {
    const n = N(r);
    return S(t, (o) => n[o]);
  }, !1, e);
}
const l = f((t) => {
  if (typeof t == "number")
    return t;
  if (typeof t == "string") {
    const e = Number(t);
    if (!Number.isNaN(e))
      return e;
  }
  throw h();
}, "number");
function k(t) {
  return /^#[\da-f]{6}$/i.test(t);
}
function q(t) {
  return /^#[\da-f]{3}$/i.test(t);
}
function A(t) {
  const e = t.replace(/\s/g, "").toLowerCase();
  if (k(e))
    return e;
  if (q(e)) {
    let n = "#";
    for (let o = 0; o < 3; o += 1)
      n += e[1 + o].repeat(2);
    return n;
  }
  const r = e.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || e.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!r)
    throw new Error(`Value "${t}" does not satisfy any of known RGB formats.`);
  return r.slice(1).reduce((n, o) => {
    const u = parseInt(o, 10).toString(16);
    return n + (u.length === 1 ? "0" : "") + u;
  }, "#");
}
const s = f((t) => {
  if (typeof t == "string" || typeof t == "number")
    return t.toString();
  throw h();
}, "string"), C = f((t) => A(s().parse(t)), "rgb");
p({
  req_id: s(),
  data: (t) => t === null ? t : s().optional().parse(t)
}), p({
  req_id: s(),
  result: (t) => t,
  error: s().optional()
}), p({ slug: s(), status: s() }), p({ status: s() }), p({ data: s().optional() }), p({
  theme_params: (t) => {
    const e = C().optional();
    return Object.entries(N(t)).reduce((r, [n, o]) => (r[n] = e.parse(o), r), {});
  }
}), p({
  height: l(),
  width: (t) => t == null ? window.innerWidth : l().parse(t),
  is_state_stable: c(),
  is_expanded: c()
}), p({ status: s() });
p({
  id: l(),
  type: s(),
  title: s(),
  photoUrl: {
    type: s().optional(),
    from: "photo_url"
  },
  username: s().optional()
}, "Chat").optional();
p({
  addedToAttachmentMenu: {
    type: c().optional(),
    from: "added_to_attachment_menu"
  },
  allowsWriteToPm: {
    type: c().optional(),
    from: "allows_write_to_pm"
  },
  firstName: {
    type: s(),
    from: "first_name"
  },
  id: l(),
  isBot: {
    type: c().optional(),
    from: "is_bot"
  },
  isPremium: {
    type: c().optional(),
    from: "is_premium"
  },
  languageCode: {
    type: s().optional(),
    from: "language_code"
  },
  lastName: {
    type: s().optional(),
    from: "last_name"
  },
  photoUrl: {
    type: s().optional(),
    from: "photo_url"
  },
  username: s().optional()
}, "User").optional();
function w(t, e) {
  return t.startsWith(e) ? t : `${e}${t}`;
}
function P(t) {
  return new URL(
    typeof t == "string" ? t : `${t.pathname || ""}${w(t.search || "", "?")}${w(t.hash || "", "#")}`,
    "http://a"
  );
}
function m(t) {
  const e = typeof t == "string" ? t.startsWith("/") : !!(t.pathname && t.pathname.startsWith("/")), r = P(t);
  return `${e ? r.pathname : r.pathname.slice(1)}${r.search}${r.hash}`;
}
function W(t) {
  const e = b(() => ({
    state: t.state,
    key: t.id,
    pathname: t.pathname,
    hash: t.hash,
    search: t.search
  }), [t]), [r, n] = O(e), o = b((i, a, d) => {
    d || (d = {}), a === void 0 && (a = d.state);
    const g = m(i);
    d.replace ? t.replace(g, a) : t.push(g, a);
  }, [t]), u = R(() => ({
    go(i) {
      t.go(i);
    },
    push: o,
    replace: o,
    createHref: (i) => t.renderPath(m(i)),
    encodeLocation: (i) => P(t.renderPath(m(i)))
  }), [t]);
  return U(() => t.on("change", () => n(e())), [t, e]), [r, u];
}
export {
  W as useIntegration
};
//# sourceMappingURL=index.js.map
